<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand Interactive Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #video-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 160px;
            height: 120px;
            z-index: 10;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
            opacity: 0.7;
        }
        video {
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror the video */
            object-fit: cover;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: sans-serif;
            font-size: 24px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading">Loading AI Models...</div>
    
    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- Configuration ---
        const PARTICLE_COUNT = 15000;
        const INTERACTION_RADIUS = 30; // Radius of hand influence
        const RETURN_SPEED = 0.05;     // How fast particles return to original spot
        const MOUSE_FORCE = 50;        // Strength of the push

        // --- Global Variables ---
        let scene, camera, renderer;
        let particles, positions, originalPositions;
        let handPosition = new THREE.Vector3(9999, 9999, 9999); // Start far away
        const clock = new THREE.Clock();

        // --- 1. Three.js Setup ---
        function initThree() {
            scene = new THREE.Scene();
            // Add some fog for depth
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            createParticles();
            
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // --- 2. Particle System ---
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            originalPositions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);

            const colorObj = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // Create a cube shape of particles
                const x = (Math.random() - 0.5) * 100;
                const y = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                originalPositions[i * 3] = x;
                originalPositions[i * 3 + 1] = y;
                originalPositions[i * 3 + 2] = z;

                // Color gradient based on position
                colorObj.setHSL((x + 50) / 100, 1.0, 0.5);
                colors[i * 3] = colorObj.r;
                colors[i * 3 + 1] = colorObj.g;
                colors[i * 3 + 2] = colorObj.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.8,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- 3. Animation & Interaction Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            // Rotate the entire cloud slightly
            particles.rotation.y = time * 0.1;
            particles.rotation.x = Math.sin(time * 0.2) * 0.1;

            updateParticles();
            
            renderer.render(scene, camera);
        }

        function updateParticles() {
            // Need to transform hand position into local particle space because the particle system is rotating
            // However, for simplicity, we will assume hand interacts in World Space.
            // Let's get World Coordinates of particles.
            // To save CPU, we do physics in Local Space. We must transform "Hand" into Local Space.
            
            const localHand = handPosition.clone();
            
            // Inverse the rotation of the particle system to find where the hand is relative to the "cube"
            localHand.applyEuler(new THREE.Euler(-particles.rotation.x, -particles.rotation.y, -particles.rotation.z));

            const positionsArray = particles.geometry.attributes.position.array;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const px = positionsArray[i * 3];
                const py = positionsArray[i * 3 + 1];
                const pz = positionsArray[i * 3 + 2];

                const ox = originalPositions[i * 3];
                const oy = originalPositions[i * 3 + 1];
                const oz = originalPositions[i * 3 + 2];

                // Calculate distance to hand
                const dx = px - localHand.x;
                const dy = py - localHand.y;
                const dz = pz - localHand.z;
                const distSq = dx * dx + dy * dy + dz * dz;

                // Interaction Physics (Repulsion)
                if (distSq < INTERACTION_RADIUS * INTERACTION_RADIUS) {
                    const dist = Math.sqrt(distSq);
                    const force = (INTERACTION_RADIUS - dist) / INTERACTION_RADIUS; 
                    
                    const angleX = dx / dist;
                    const angleY = dy / dist;
                    const angleZ = dz / dist;

                    positionsArray[i * 3] += angleX * force * 2;
                    positionsArray[i * 3 + 1] += angleY * force * 2;
                    positionsArray[i * 3 + 2] += angleZ * force * 2;
                } else {
                    // Return to original position (Spring force)
                    positionsArray[i * 3] += (ox - px) * RETURN_SPEED;
                    positionsArray[i * 3 + 1] += (oy - py) * RETURN_SPEED;
                    positionsArray[i * 3 + 2] += (oz - pz) * RETURN_SPEED;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 4. MediaPipe Hands Setup ---
        const videoElement = document.getElementById('input-video');

        function onResults(results) {
            document.getElementById('loading').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // Get the first hand detected
                const landmarks = results.multiHandLandmarks[0];
                
                // Index Finger Tip is landmark #8
                const indexFinger = landmarks[8];

                // Map video coordinates (0 to 1) to Three.js World Coordinates
                // Screen space is roughly -80 to 80 based on our camera Z position
                const x = (0.5 - indexFinger.x) * 180; // Flip X because webcam is mirrored
                const y = (0.5 - indexFinger.y) * 120; // Invert Y
                
                // Approximate Z depth using hand size or just fix it at 0
                // Simple approach: Hand is generally in front of the object
                const z = 20; 

                // Smooth movement (Linear Interpolation)
                handPosition.lerp(new THREE.Vector3(x, y, z), 0.1);
            } else {
                // If no hand, move "interaction point" far away
                handPosition.lerp(new THREE.Vector3(9999, 9999, 9999), 0.05);
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        cameraUtils.start();

        // Start Three.js
        initThree();

    </script>
</body>
</html>